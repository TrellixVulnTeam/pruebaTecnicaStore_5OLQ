{"version":3,"file":"virtual-scroll.d.ts","sources":["virtual-scroll.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { ElementRef, IterableDiffers, NgZone, SimpleChanges, TrackByFunction } from '@angular/core';\r\nimport { FooterHeightFn, HeaderFn, HeaderHeightFn, ItemHeightFn } from '@ionic/core';\r\nimport { VirtualFooter } from './virtual-footer';\r\nimport { VirtualHeader } from './virtual-header';\r\nimport { VirtualItem } from './virtual-item';\r\nexport declare interface IonVirtualScroll {\r\n    /**\r\n     * It is important to provide this\r\n     * if virtual item height will be significantly larger than the default\r\n     * The approximate height of each virtual item template's cell.\r\n     * This dimension is used to help determine how many cells should\r\n     * be created when initialized, and to help calculate the height of\r\n     * the scrollable area. This height value can only use `px` units.\r\n     * Note that the actual rendered size of each cell comes from the\r\n     * app's CSS, whereas this approximation is used to help calculate\r\n     * initial dimensions before the item has been rendered.\r\n     */\r\n    approxItemHeight: number;\r\n    /**\r\n     * The approximate height of each header template's cell.\r\n     * This dimension is used to help determine how many cells should\r\n     * be created when initialized, and to help calculate the height of\r\n     * the scrollable area. This height value can only use `px` units.\r\n     * Note that the actual rendered size of each cell comes from the\r\n     * app's CSS, whereas this approximation is used to help calculate\r\n     * initial dimensions before the item has been rendered.\r\n     */\r\n    approxHeaderHeight: number;\r\n    /**\r\n     * The approximate width of each footer template's cell.\r\n     * This dimension is used to help determine how many cells should\r\n     * be created when initialized, and to help calculate the height of\r\n     * the scrollable area. This height value can only use `px` units.\r\n     * Note that the actual rendered size of each cell comes from the\r\n     * app's CSS, whereas this approximation is used to help calculate\r\n     * initial dimensions before the item has been rendered.\r\n     */\r\n    approxFooterHeight: number;\r\n    /**\r\n     * Section headers and the data used within its given\r\n     * template can be dynamically created by passing a function to `headerFn`.\r\n     * For example, a large list of contacts usually has dividers between each\r\n     * letter in the alphabet. App's can provide their own custom `headerFn`\r\n     * which is called with each record within the dataset. The logic within\r\n     * the header function can decide if the header template should be used,\r\n     * and what data to give to the header template. The function must return\r\n     * `null` if a header cell shouldn't be created.\r\n     */\r\n    headerFn?: HeaderFn;\r\n    /**\r\n     * Section footers and the data used within its given\r\n     * template can be dynamically created by passing a function to `footerFn`.\r\n     * The logic within the footer function can decide if the footer template\r\n     * should be used, and what data to give to the footer template. The function\r\n     * must return `null` if a footer cell shouldn't be created.\r\n     */\r\n    footerFn?: HeaderFn;\r\n    /**\r\n     * The data that builds the templates within the virtual scroll.\r\n     * It's important to note that when this data has changed, then the\r\n     * entire virtual scroll is reset, which is an expensive operation and\r\n     * should be avoided if possible.\r\n     */\r\n    items?: any[] | null;\r\n    /**\r\n     * An optional function that maps each item within their height.\r\n     * When this function is provided, heavy optimizations and fast path can be taked by\r\n     * `ion-virtual-scroll` leading to massive performance improvements.\r\n     *\r\n     * This function allows to skip all DOM reads, which can be Doing so leads\r\n     * to massive performance\r\n     */\r\n    itemHeight?: ItemHeightFn;\r\n    /**\r\n     * An optional function that maps each item header within their height.\r\n     */\r\n    headerHeight?: HeaderHeightFn;\r\n    /**\r\n     * An optional function that maps each item footer within their height.\r\n     */\r\n    footerHeight?: FooterHeightFn;\r\n    /**\r\n     * Same as `ngForTrackBy` which can be used on `ngFor`.\r\n     */\r\n    trackBy: TrackByFunction<any>;\r\n    /**\r\n     * This method marks the tail the items array as dirty, so they can be re-rendered.  It's equivalent to calling:  ```js    * virtualScroll.checkRange(lastItemLen, items.length - lastItemLen);    * ```\r\n     */\r\n    'checkEnd': () => void;\r\n    /**\r\n     * This method marks a subset of items as dirty, so they can be re-rendered. Items should be marked as dirty any time the content or their style changes.  The subset of items to be updated can are specifing by an offset and a length.\r\n     */\r\n    'checkRange': (offset: number, len?: number) => void;\r\n    /**\r\n     * Returns the position of the virtual item at the given index.\r\n     */\r\n    'positionForItem': (index: number) => Promise<number>;\r\n}\r\nexport declare class IonVirtualScroll {\r\n    private z;\r\n    private iterableDiffers;\r\n    private differ?;\r\n    private el;\r\n    private refMap;\r\n    itmTmp: VirtualItem;\r\n    hdrTmp: VirtualHeader;\r\n    ftrTmp: VirtualFooter;\r\n    constructor(z: NgZone, iterableDiffers: IterableDiffers, elementRef: ElementRef);\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n    ngDoCheck(): void;\r\n    private nodeRender;\r\n    private getComponent;\r\n}\r\n"]}
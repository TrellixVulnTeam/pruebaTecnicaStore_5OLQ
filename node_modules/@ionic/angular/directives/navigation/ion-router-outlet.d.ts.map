{"version":3,"file":"ion-router-outlet.d.ts","sources":["ion-router-outlet.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { Location } from '@angular/common';\r\nimport { ComponentFactoryResolver, ComponentRef, ElementRef, EventEmitter, NgZone, OnDestroy, OnInit, ViewContainerRef } from '@angular/core';\r\nimport { ActivatedRoute, ChildrenOutletContexts, OutletContext, Router } from '@angular/router';\r\nimport { AnimationBuilder } from '../../';\r\nimport { Config } from '../../providers/config';\r\nimport { NavController } from '../../providers/nav-controller';\r\nimport { RouteView } from './stack-utils';\r\nexport declare class IonRouterOutlet implements OnDestroy, OnInit {\r\n    private parentContexts;\r\n    private location;\r\n    private resolver;\r\n    private config;\r\n    private navCtrl;\r\n    readonly parentOutlet?: IonRouterOutlet;\r\n    nativeEl: HTMLIonRouterOutletElement;\r\n    private activated;\r\n    activatedView: RouteView | null;\r\n    private _activatedRoute;\r\n    private _swipeGesture?;\r\n    private name;\r\n    private stackCtrl;\r\n    private proxyMap;\r\n    private currentActivatedRoute$;\r\n    tabsPrefix: string | undefined;\r\n    stackEvents: EventEmitter<any>;\r\n    activateEvents: EventEmitter<any>;\r\n    deactivateEvents: EventEmitter<any>;\r\n    animation: AnimationBuilder;\r\n    animated: boolean;\r\n    swipeGesture: boolean;\r\n    constructor(parentContexts: ChildrenOutletContexts, location: ViewContainerRef, resolver: ComponentFactoryResolver, name: string, tabs: string, config: Config, navCtrl: NavController, commonLocation: Location, elementRef: ElementRef, router: Router, zone: NgZone, activatedRoute: ActivatedRoute, parentOutlet?: IonRouterOutlet);\r\n    ngOnDestroy(): void;\r\n    getContext(): OutletContext | null;\r\n    ngOnInit(): void;\r\n    readonly isActivated: boolean;\r\n    readonly component: object;\r\n    readonly activatedRoute: ActivatedRoute;\r\n    readonly activatedRouteData: any;\r\n    /**\r\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\r\n     */\r\n    detach(): ComponentRef<any>;\r\n    /**\r\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\r\n     */\r\n    attach(_ref: ComponentRef<any>, _activatedRoute: ActivatedRoute): void;\r\n    deactivate(): void;\r\n    activateWith(activatedRoute: ActivatedRoute, resolver: ComponentFactoryResolver | null): void;\r\n    /**\r\n     * Returns `true` if there are pages in the stack to go back.\r\n     */\r\n    canGoBack(deep?: number, stackId?: string): boolean;\r\n    /**\r\n     * Resolves to `true` if it the outlet was able to sucessfully pop the last N pages.\r\n     */\r\n    pop(deep?: number, stackId?: string): Promise<boolean>;\r\n    /**\r\n     * Returns the URL of the active page of each stack.\r\n     */\r\n    getLastUrl(stackId?: string): string | undefined;\r\n    /**\r\n     * Returns the RouteView of the active page of each stack.\r\n     * @internal\r\n     */\r\n    getLastRouteView(stackId?: string): RouteView | undefined;\r\n    /**\r\n     * Returns the root view in the tab stack.\r\n     * @internal\r\n     */\r\n    getRootView(stackId?: string): RouteView | undefined;\r\n    /**\r\n     * Returns the active stack ID. In the context of ion-tabs, it means the active tab.\r\n     */\r\n    getActiveStackId(): string | undefined;\r\n    /**\r\n     * Since the activated route can change over the life time of a component in an ion router outlet, we create\r\n     * a proxy so that we can update the values over time as a user navigates back to components already in the stack.\r\n     */\r\n    private createActivatedRouteProxy;\r\n    /**\r\n     * Create a wrapped observable that will switch to the latest activated route matched by the given component\r\n     */\r\n    private proxyObservable;\r\n    /**\r\n     * Updates the activated route proxy for the given component to the new incoming router state\r\n     */\r\n    private updateActivatedRouteProxy;\r\n}\r\n"]}